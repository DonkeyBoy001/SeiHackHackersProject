'use strict';

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');
Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.verifyDigest32 = exports.pubKeyToKeyPair = exports.pubKeyToBytes = exports.isValidSeiAddress = exports.getAddressFromPubKey = void 0;
var _encoding = require('@cosmjs/encoding');
var _cryptoJs = _interopRequireDefault(require('crypto-js'));
var _elliptic = require('elliptic');
var isValidSeiAddress = function isValidSeiAddress(address) {
	try {
		var _fromBech = (0, _encoding.fromBech32)(address),
			prefix = _fromBech.prefix;
		return prefix && prefix === 'sei';
	} catch (e) {
		return false;
	}
};
exports.isValidSeiAddress = isValidSeiAddress;
var pubKeyToKeyPair = function pubKeyToKeyPair(pubKey) {
	var secp256k1 = new _elliptic.ec('secp256k1');
	return secp256k1.keyFromPublic(Buffer.from(pubKey).toString('hex'), 'hex');
};
exports.pubKeyToKeyPair = pubKeyToKeyPair;
var pubKeyToBytes = function pubKeyToBytes(pubKey, uncompressed) {
	if (uncompressed && pubKey.length === 65) {
		return pubKey;
	}
	if (!uncompressed && pubKey.length === 33) {
		return pubKey;
	}
	var keyPair = pubKeyToKeyPair(pubKey);
	if (uncompressed) {
		return new Uint8Array(Buffer.from(keyPair.getPublic().encode('hex', false), 'hex'));
	} else {
		return new Uint8Array(Buffer.from(keyPair.getPublic().encodeCompressed('hex'), 'hex'));
	}
};
exports.pubKeyToBytes = pubKeyToBytes;
var getAddressFromPubKey = function getAddressFromPubKey(pubKey) {
	var hash = _cryptoJs['default'].SHA256(_cryptoJs['default'].lib.WordArray.create(pubKeyToBytes(pubKey))).toString();
	hash = _cryptoJs['default'].RIPEMD160(_cryptoJs['default'].enc.Hex.parse(hash)).toString();
	return new Uint8Array(Buffer.from(hash, 'hex'));
};
exports.getAddressFromPubKey = getAddressFromPubKey;
var verifyDigest32 = function verifyDigest32(digest, signature, pubKey) {
	if (digest.length !== 32) {
		throw new Error('Invalid length of digest to verify: '.concat(digest.length));
	}
	if (signature.length !== 64) {
		throw new Error('Invalid length of signature: '.concat(signature.length));
	}
	var secp256k1 = new _elliptic.ec('secp256k1');
	var r = signature.slice(0, 32);
	var s = signature.slice(32);
	return secp256k1.verify(
		digest,
		{
			r: Buffer.from(r).toString('hex'),
			s: Buffer.from(s).toString('hex')
		},
		pubKeyToKeyPair(pubKey)
	);
};
exports.verifyDigest32 = verifyDigest32;
//# sourceMappingURL=address.js.map
