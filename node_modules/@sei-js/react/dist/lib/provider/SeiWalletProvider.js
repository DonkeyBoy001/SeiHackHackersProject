'use strict';

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');
var _typeof = require('@babel/runtime/helpers/typeof');
Object.defineProperty(exports, '__esModule', {
	value: true
});
exports['default'] = exports.SeiWalletContext = void 0;
var _regenerator = _interopRequireDefault(require('@babel/runtime/regenerator'));
var _asyncToGenerator2 = _interopRequireDefault(require('@babel/runtime/helpers/asyncToGenerator'));
var _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray'));
var _react = _interopRequireWildcard(require('react'));
var _components = require('../components');
var _helpers = require('./helpers');
function _getRequireWildcardCache(nodeInterop) {
	if (typeof WeakMap !== 'function') return null;
	var cacheBabelInterop = new WeakMap();
	var cacheNodeInterop = new WeakMap();
	return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
		return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
	})(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
	if (!nodeInterop && obj && obj.__esModule) {
		return obj;
	}
	if (obj === null || (_typeof(obj) !== 'object' && typeof obj !== 'function')) {
		return { default: obj };
	}
	var cache = _getRequireWildcardCache(nodeInterop);
	if (cache && cache.has(obj)) {
		return cache.get(obj);
	}
	var newObj = {};
	var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	for (var key in obj) {
		if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
			var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
			if (desc && (desc.get || desc.set)) {
				Object.defineProperty(newObj, key, desc);
			} else {
				newObj[key] = obj[key];
			}
		}
	}
	newObj['default'] = obj;
	if (cache) {
		cache.set(obj, newObj);
	}
	return newObj;
}
var SeiWalletContext = /*#__PURE__*/ (0, _react.createContext)({
	chainId: '',
	restUrl: '',
	rpcUrl: '',
	accounts: [],
	connect: function connect() {
		return undefined;
	},
	disconnect: function disconnect() {
		return undefined;
	},
	setConnectionError: function setConnectionError() {
		return undefined;
	},
	setTargetWallet: function setTargetWallet() {
		return undefined;
	},
	setShowConnectModal: function setShowConnectModal() {
		return undefined;
	},
	wallets: []
});
exports.SeiWalletContext = SeiWalletContext;
var SeiWalletProvider = function SeiWalletProvider(_ref) {
	var children = _ref.children,
		chainConfiguration = _ref.chainConfiguration,
		wallets = _ref.wallets,
		autoConnect = _ref.autoConnect;
	var autoConnectSeiWallet = typeof autoConnect === 'string' ? (0, _helpers.findWalletByWindowKey)(autoConnect) : autoConnect;
	var _useState = (0, _react.useState)(autoConnectSeiWallet),
		_useState2 = (0, _slicedToArray2['default'])(_useState, 2),
		targetWallet = _useState2[0],
		setTargetWallet = _useState2[1];
	var _useState3 = (0, _react.useState)(),
		_useState4 = (0, _slicedToArray2['default'])(_useState3, 2),
		offlineSigner = _useState4[0],
		setOfflineSigner = _useState4[1];
	var _useState5 = (0, _react.useState)(),
		_useState6 = (0, _slicedToArray2['default'])(_useState5, 2),
		connectionError = _useState6[0],
		setConnectionError = _useState6[1];
	var _useState7 = (0, _react.useState)([]),
		_useState8 = (0, _slicedToArray2['default'])(_useState7, 2),
		accounts = _useState8[0],
		setAccounts = _useState8[1];
	var _useState9 = (0, _react.useState)(false),
		_useState10 = (0, _slicedToArray2['default'])(_useState9, 2),
		showConnectModal = _useState10[0],
		setShowConnectModal = _useState10[1];
	var _useState11 = (0, _react.useState)(),
		_useState12 = (0, _slicedToArray2['default'])(_useState11, 2),
		connectedWallet = _useState12[0],
		setConnectedWallet = _useState12[1];
	var filteredWallets = wallets.reduce(function (acc, wallet) {
		var seiWallet = typeof wallet === 'string' ? (0, _helpers.findWalletByWindowKey)(wallet) : wallet;
		if (seiWallet !== undefined) acc.push(seiWallet);
		return acc;
	}, []);
	var disconnect = function disconnect() {
		setTargetWallet(undefined);
		setOfflineSigner(undefined);
		setAccounts([]);
		setConnectedWallet(undefined);
	};
	var connectToChain = /*#__PURE__*/ (function () {
		var _ref2 = (0, _asyncToGenerator2['default'])(
			/*#__PURE__*/ _regenerator['default'].mark(function _callee() {
				var enableResponse, fetchedOfflineSigner, fetchedAccounts;
				return _regenerator['default'].wrap(
					function _callee$(_context) {
						while (1)
							switch ((_context.prev = _context.next)) {
								case 0:
									if (targetWallet) {
										_context.next = 2;
										break;
									}
									return _context.abrupt('return');
								case 2:
									_context.prev = 2;
									if (window[targetWallet.walletInfo.windowKey]) {
										_context.next = 6;
										break;
									}
									setConnectionError(targetWallet.walletInfo.windowKey);
									return _context.abrupt('return');
								case 6:
									_context.next = 8;
									return targetWallet.connect(chainConfiguration.chainId);
								case 8:
									enableResponse = _context.sent;
									_context.next = 11;
									return targetWallet.getOfflineSigner(chainConfiguration.chainId);
								case 11:
									fetchedOfflineSigner = _context.sent;
									if (fetchedOfflineSigner) {
										_context.next = 16;
										break;
									}
									setConnectionError(targetWallet.walletInfo.windowKey);
									disconnect();
									return _context.abrupt('return');
								case 16:
									_context.next = 18;
									return targetWallet.getAccounts(chainConfiguration.chainId);
								case 18:
									fetchedAccounts = _context.sent;
									if (!(fetchedAccounts.length === 0)) {
										_context.next = 25;
										break;
									}
									setConnectionError(targetWallet.walletInfo.windowKey);
									disconnect();
									return _context.abrupt('return');
								case 25:
									setShowConnectModal(false);
									setOfflineSigner(fetchedOfflineSigner);
									setAccounts(fetchedAccounts);
									setConnectedWallet(targetWallet);
								case 29:
									_context.next = 36;
									break;
								case 31:
									_context.prev = 31;
									_context.t0 = _context['catch'](2);
									console.error('Error connecting to wallet', _context.t0);
									setConnectionError(targetWallet.walletInfo.windowKey);
									return _context.abrupt('return');
								case 36:
								case 'end':
									return _context.stop();
							}
					},
					_callee,
					null,
					[[2, 31]]
				);
			})
		);
		return function connectToChain() {
			return _ref2.apply(this, arguments);
		};
	})();
	(0, _react.useEffect)(
		function () {
			if (targetWallet) {
				connectToChain().then();
			} else {
				setOfflineSigner(undefined);
				setAccounts([]);
				setConnectedWallet(undefined);
			}
		},
		[targetWallet, chainConfiguration.chainId]
	);
	var contextValue = {
		chainId: chainConfiguration.chainId,
		restUrl: chainConfiguration.restUrl,
		rpcUrl: chainConfiguration.rpcUrl,
		wallets: filteredWallets,
		connect: setTargetWallet,
		disconnect: disconnect,
		accounts: accounts,
		offlineSigner: offlineSigner,
		connectedWallet: connectedWallet,
		targetWallet: targetWallet,
		setTargetWallet: setTargetWallet,
		showConnectModal: showConnectModal,
		setShowConnectModal: setShowConnectModal,
		connectionError: connectionError,
		setConnectionError: setConnectionError
	};
	return /*#__PURE__*/ _react['default'].createElement(
		SeiWalletContext.Provider,
		{
			value: contextValue
		},
		children,
		/*#__PURE__*/ _react['default'].createElement(_components.WalletSelectModal, {
			wallets: filteredWallets
		})
	);
};
var _default = SeiWalletProvider;
exports['default'] = _default;
//# sourceMappingURL=SeiWalletProvider.js.map
